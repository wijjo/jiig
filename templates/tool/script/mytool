#!/usr/bin/env jiig-run
"""
mytool (jiig monolithic tool script - jiig-run version).

Jiig-run automatically deals with the Python package load path, manages any
required virtual environment, and scrapes tool metadata from simple
configuration variables.
"""

import jiig


class TaskCase(jiig.Task):
    """Convert text case (default is "smart" conversion)."""

    upper: jiig.boolean('convert to all-uppercase', cli_flags='-u')
    lower: jiig.boolean('convert to all-lowercase', cli_flags='-l')
    blocks: jiig.text('text block(s) to convert', repeat=(1, None))

    def on_run(self, _runtime: jiig.Runtime):
        if self.upper and self.lower:
            raise RuntimeError('Conflicting upper/lower options specified.')
        if not self.upper and not self.lower:
            # "Smart" conversion checks first character of first block.
            to_upper = self.blocks[0][:1].islower()
        else:
            to_upper = self.upper
        text = ' '.join(self.blocks)
        if to_upper:
            output_text = text.upper()
        else:
            output_text = text.lower()
        print(output_text)


class TaskWords(jiig.Task):
    """Count words using primitive whitespace splitting."""

    blocks: jiig.text('text block(s) with words to count', repeat=(1, None))

    def on_run(self, _runtime: jiig.Runtime):
        count = len(' '.join(self.blocks).split())
        print(f'The word count is {count}.')


class TaskCalc(jiig.Task):
    """Evaluate formula using Python interpreter."""

    blocks: jiig.text('formula block(s) to evaluate', repeat=(1, None))

    def on_run(self, _runtime: jiig.Runtime):
        result = eval(' '.join(self.blocks))
        print(f'The result is {result}.')


class Task(jiig.Task,
           tasks={'case': TaskCase,
                  'words': TaskWords,
                  'calc': TaskCalc}
          ):
    """Various text manipulations."""
    pass


TOOL_NAME = 'mytool'

DESCRIPTION = 'mytool description.'

ROOT_TASK = Task

# PIP_PACKAGES = []
