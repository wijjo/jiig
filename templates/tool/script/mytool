#!/usr/bin/env jiig-run
"""
mytool (jiig monolithic tool script - jiig-run version).

Jiig-run automatically deals with the Python package load path, manages any
required virtual environment, and scrapes tool metadata from simple
configuration variables.
"""

import jiig


@jiig.task
def case(
    runtime: jiig.Runtime,
    upper: jiig.f.boolean('convert to all-uppercase', cli_flags='-u'),
    lower: jiig.f.boolean('convert to all-lowercase', cli_flags='-l'),
    blocks: jiig.f.text('text block(s) to convert', repeat=(1, None)),
):
    """Convert text case (default is "smart" conversion)."""
    if upper and lower:
        raise RuntimeError('Conflicting upper/lower options specified.')
    if not upper and not lower:
        # "Smart" conversion checks first character of first block.
        to_upper = blocks[0][:1].islower()
    else:
        to_upper = upper
    text = ' '.join(blocks)
    if to_upper:
        output_text = text.upper()
    else:
        output_text = text.lower()
    runtime.message(output_text)


@jiig.task
def words(
    runtime: jiig.Runtime,
    blocks: jiig.f.text('text block(s) with words to count', repeat=(1, None)),
):
    """Count words using primitive whitespace splitting."""
    count = len(' '.join(blocks).split())
    runtime.message(f'The word count is {count}.')


@jiig.task
def calc(
    runtime: jiig.Runtime,
    blocks: jiig.f.text('formula block(s) to evaluate', repeat=(1, None)),
):
    """Evaluate formula using Python interpreter."""
    result = eval(' '.join(blocks))
    runtime.message(f'The result is {result}.')


@jiig.task(tasks=(case, words, calc))
def root(_runtime: jiig.Runtime):
    """Various text manipulations."""
    pass


TOOL_NAME = 'mytool'

DESCRIPTION = 'mytool description.'

ROOT_TASK = root

# PIP_PACKAGES = []
