#!/usr/bin/env python3

"""
Front end script for Jiig-based tools.

Use as the program in the "shebang" line of the main script.

## Responsibilities
- Load tool parameters.
- Check whether or not a virtual environment is needed.
- Build any needed virtual environment.
- Restart inside the virtual environment, as needed.
- Load the original tool script after any restart.
- Parse the command line.
- Execute task(s).
"""
import sys
import os
from typing import Text, List, Dict

JIIG_ROOT = os.path.dirname(os.path.realpath(sys.argv[0]))
JIIG_LIB = os.path.join(JIIG_ROOT, 'lib')
# Add the Jiig library path if missing.
if JIIG_LIB not in sys.path:
    sys.path.insert(0, JIIG_LIB)
# The automatically-added Jiig root path (added due to this script) is not used, so lose it.
if JIIG_ROOT in sys.path:
    sys.path.remove(JIIG_ROOT)

from jiig.utility.init_file import ParamData, ParamList, ParamFolder, ParamFolderList, ParamLoader
from jiig.external.task_runner import TaskRunner, RunnerData
from jiig.internal import global_data, tool_options
from jiig.internal.aliases import AliasManager, expand_alias_name
from jiig.internal.parser import pre_parse_command_line, parse_command_line, CommandLineData
from jiig.internal.registry import get_mapped_task_by_dest_name, get_runner_factory
from jiig.utility.cli import make_dest_name
from jiig.utility.console import abort, log_message, print_call_stack
from jiig.utility.python import build_virtual_environment, execute_source

INIT_PARAM_TYPES = [
    ParamFolderList('LIB_FOLDERS', default_value=['lib']),
    ParamFolder('TEST_ROOT', default_value='test'),
    ParamFolder('VENV_ROOT', default_value='venv'),
    ParamList('PIP_PACKAGES', unique=True, default_value=[]),
]


def pre_parse_arguments(cli_args: List[Text]) -> List[Text]:
    """
    Pre-parse the command line to set global options.

    :param cli_args: tool command line arguments
    :return: unparsed trailing command line arguments
    """
    # Enable global options based on partial command line pre-parsing.
    args, trailing_args = pre_parse_command_line(cli_args=cli_args)
    if args.VERBOSE:
        # Dry-run implies verbose.
        global_data.set_verbose(args.VERBOSE or args.DRY_RUN)
    if args.DEBUG:
        global_data.set_debug(args.DEBUG)
    if args.DRY_RUN:
        global_data.set_dry_run(args.DRY_RUN)
    # Drop the '--' that was needed for restarting in the virtual environment.
    if trailing_args and trailing_args[0] == '--':
        return trailing_args[1:]
    return trailing_args


def initialize(script_path: Text,
               tool_path: Text,
               cli_args: List[Text]
               ) -> ParamData:
    """
    Load init file parameters and check if a virtual environment is required.

    Will not return if it needs to restart in the virtual environment.

    :param script_path: path of this script
    :param tool_path: path of tool script
    :param cli_args: tool command line arguments
    :return: init file parameter data
    """
    # Load tool init file
    tool_root = os.path.dirname(os.path.realpath(tool_path))
    init_path = os.path.join(tool_root, global_data.init_file_name)
    param_loader = ParamLoader(INIT_PARAM_TYPES)
    log_message(f'Load configuration file "{init_path}".', verbose=True)
    param_loader.load_file(init_path)
    init_params = param_loader.get_data()

    # Prepare the Python module loading path.
    folders = [JIIG_LIB]
    if init_params.LIB_FOLDERS:
        for tool_lib_folder in reversed(init_params.LIB_FOLDERS):
            if tool_lib_folder not in sys.path:
                sys.path.insert(0, tool_lib_folder)
                folders.insert(0, tool_lib_folder)
    global_data.set_library_folders(folders)

    # May not need a virtual environment.
    if not init_params.VENV_ROOT:
        return init_params

    # May already be inside the virtual environment
    venv_interpreter = os.path.join(init_params.VENV_ROOT, 'bin', 'python')
    if sys.executable == venv_interpreter:
        return init_params

    # May meed to build the virtual environment.
    # The following call does nothing if it exists.
    build_virtual_environment(init_params.VENV_ROOT,
                              packages=init_params.PIP_PACKAGES,
                              rebuild=False,
                              quiet=True)

    # Restart inside the virtual environment. Does not return.
    # '--' prevents the Python program from confusing jiig/tool options with its own.
    log_message('Re-running inside virtual environment...', verbose=True)
    os.execl(venv_interpreter,
             venv_interpreter,
             script_path,
             tool_path,
             '--',
             *cli_args)


def load_tool(script_path: Text, init_params: Dict) -> ParamData:
    """
    Load the tool script and post-process global tool options.

    :param script_path: path to tool script
    :param init_params: data loaded from init file
    """
    try:
        script_symbols = execute_source(file=script_path)
        # If no name was provided use the script base name.
        if not tool_options.name:
            tool_options.set_name(os.path.basename(script_path))
        # If no description was provided try to scrape it from the doc string, if it exists.
        if not tool_options.description:
            doc_string = script_symbols.get('__doc__', '').strip()
            if doc_string:
                tool_options.set_description(doc_string.splitlines()[0])
        if not tool_options.description:
            tool_options.set_description('(no description provided)')
        # Load standard modules, if enabled.
        if not tool_options.disable_help:
            import jiig.tasks.help      # noqa
        if not tool_options.disable_alias:
            import jiig.tasks.alias     # noqa
        # Initialize tool parameters.
        tool_params = ParamData(init_params)
        tool_params['JIIG_ROOT'] = JIIG_ROOT
        tool_params['TOOL_NAME'] = tool_options.name
        tool_params['TOOL_DESCRIPTION'] = tool_options.description
        return tool_params
    except Exception as exc:
        if global_data.debug:
            print_call_stack(tb=sys.exc_info()[2], label='Exception')
        abort('Exception occurred while loading tool.', exc)


def expand_alias(tool_name: Text, command_args: List[Text]) -> List[Text]:
    """
    Finalize command line argument list.

    Remove '--' that may have been inserted when restarting in the venv.

    Expanding an alias, if one is the first argument.

    :param tool_name:
    :param command_args:
    :return:
    """
    if not command_args:
        return []
    if not expand_alias_name(command_args[0]):
        return command_args
    alias_manager = AliasManager(tool_name=tool_name)
    alias = alias_manager.resolve_alias(command_args[0])
    if not alias:
        abort(f'Alias "{command_args[0]}" not found.')
    return alias.command + command_args[1:]


def need_trailing_arguments(command_args: List[Text]) -> bool:
    """
    Check if the task command requires a trailing argument capture.

    :param command_args: command line arguments (only the first is used)
    :return: True if trailing arguments must be captured
    """
    if not command_args:
        return False
    # Access the mapped task to see if trailing arguments are used.
    dest_name = make_dest_name(command_args[0])
    primary_mt = get_mapped_task_by_dest_name(dest_name)
    return primary_mt and primary_mt.capture_trailing_arguments


def create_runner(data: RunnerData) -> TaskRunner:
    runner_factory = get_runner_factory()
    if runner_factory:
        return runner_factory(data)
    return TaskRunner(data)


def run_tool_task(cli_results: CommandLineData,
                  tool_params: ParamData):
    """
    Run the tool task based on the parsed command line.

    :param cli_results: results of parsing the command line
    :param tool_params: tool parameters based on init file and tool script
    """
    # Bundle the data shared with tasks through the task runner.
    runner_data = RunnerData(cli_results.args,
                             cli_results.trailing_args,
                             cli_results.help_formatters,
                             tool_params)
    try:
        # Execute task dependencies first.
        for dependency_task in cli_results.mapped_task.execution_tasks:
            dependency_task.task_function(create_runner(runner_data))
        # Then execute the primary task.
        cli_results.mapped_task.task_function(create_runner(runner_data))
    except RuntimeError as exc:
        abort(f'{exc.__class__.__name__}("{exc}")', cli_results.args)
    except KeyboardInterrupt:
        print('')


def main():
    # Skip leading '--', which is used to hide Jiig options from the Python
    # executable when restarting in the virtual environment.
    if len(sys.argv) < 2 or not os.path.isfile(sys.argv[1]):
        sys.stderr.write(f'FATAL: jiig-run should not be run directly.{os.linesep}')
        sys.exit(1)
    cli_args = sys.argv[2:]
    if cli_args and cli_args[0] == '--':
        cli_args = cli_args[1:]
    # Get global options and trailing command arguments.
    tool_args = pre_parse_arguments(cli_args)
    # Initialize the runtime environment. May not return if a venv is required.
    init_params = initialize(sys.argv[0], sys.argv[1], cli_args)
    # Load the tool to let it initialize.
    tool_params = load_tool(sys.argv[1], init_params)
    # Expand an alias, as needed.
    final_tool_args = expand_alias(tool_params.TOOL_NAME, tool_args)
    # Check if trailing arguments should be captured, e.g. for the "alias" task.
    capture_trailing = need_trailing_arguments(final_tool_args)
    # Parse the command line for real.
    cli_results = parse_command_line(cli_args=final_tool_args,
                                     name=tool_params.TOOL_NAME,
                                     description=tool_params.TOOL_DESCRIPTION,
                                     capture_trailing=capture_trailing)
    # Run the tool to invoke the specified task.
    run_tool_task(cli_results, tool_params)


if __name__ == '__main__':
    main()
