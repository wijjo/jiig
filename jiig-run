#!/usr/bin/env python3

"""
Front end script for Jiig-based tools.

Use as the program in the "shebang" line of the main script.

## Responsibilities
- Load tool parameters.
- Check whether or not a virtual environment is needed.
- Build any needed virtual environment.
- Restart inside the virtual environment, as needed.
- Load the original tool script after any restart.
- Parse the command line.
- Execute task(s).
"""
import sys
import os
from typing import Text, List, Dict

JIIG_ROOT = os.path.dirname(os.path.realpath(sys.argv[0]))
JIIG_LIB = os.path.join(JIIG_ROOT, 'lib')
# Add the Jiig library path if missing.
if JIIG_LIB not in sys.path:
    sys.path.insert(0, JIIG_LIB)
# The automatically-added Jiig root path (added due to this script) is not used, so lose it.
if JIIG_ROOT in sys.path:
    sys.path.remove(JIIG_ROOT)

from jiig import init_file, task_runner
from jiig.internal import registry, parser, global_data, aliases    # noqa
from jiig.utility.cli import make_dest_name
from jiig.utility.console import abort, log_message
from jiig.utility.python import build_virtual_environment, execute_source

INIT_PARAM_TYPES = [
    init_file.ParamFolderList('LIB_FOLDERS', default_value=['lib']),
    init_file.ParamFolder('TEST_ROOT', default_value='test'),
    init_file.ParamFolder('VENV_ROOT', default_value='venv'),
    init_file.ParamList('PIP_PACKAGES', unique=True, default_value=[]),
]


def pre_parse_arguments(cli_args: List[Text]) -> List[Text]:
    """
    Pre-parse the command line to set global options.

    :param cli_args: tool command line arguments
    :return: unparsed trailing command line arguments
    """
    # Enable global options based on partial command line pre-parsing.
    args, trailing_args = parser.pre_parse_command_line(cli_args=cli_args)
    if args.VERBOSE:
        # Dry-run implies verbose.
        global_data.VERBOSE = args.VERBOSE or args.DRY_RUN
    if args.DEBUG:
        global_data.DEBUG = args.DEBUG
    if args.DRY_RUN:
        global_data.DRY_RUN = args.DRY_RUN
    # Drop the '--' that was needed for restarting in the virtual environment.
    if trailing_args and trailing_args[0] == '--':
        return trailing_args[1:]
    return trailing_args


def initialize(script_path: Text,
               tool_path: Text,
               cli_args: List[Text]
               ) -> init_file.ParamData:
    """
    Load init file parameters and check if a virtual environment is required.

    Will not return if it needs to restart in the virtual environment.

    :param script_path: path of this script
    :param tool_path: path of tool script
    :param cli_args: tool command line arguments
    :return: init file parameter data
    """
    # Load tool init file
    tool_root = os.path.dirname(os.path.realpath(tool_path))
    init_path = os.path.join(tool_root, global_data.INIT_FILE)
    param_loader = init_file.ParamLoader(INIT_PARAM_TYPES)
    log_message(f'Load configuration file "{init_path}".', verbose=True)
    param_loader.load_file(init_path)
    init_params = param_loader.get_data()

    # Prepare the Python module loading path.
    global_data.LIBRARY_FOLDERS = [JIIG_LIB]
    if init_params.LIB_FOLDERS:
        for tool_lib_folder in reversed(init_params.LIB_FOLDERS):
            if tool_lib_folder not in sys.path:
                sys.path.insert(0, tool_lib_folder)
                global_data.LIBRARY_FOLDERS.insert(0, tool_lib_folder)

    # May not need a virtual environment.
    if not init_params.VENV_ROOT:
        return init_params

    # May already be inside the virtual environment
    venv_interpreter = os.path.join(init_params.VENV_ROOT, 'bin', 'python')
    if sys.executable == venv_interpreter:
        return init_params

    # May meed to build the virtual environment.
    # The following call does nothing if it exists.
    build_virtual_environment(init_params.VENV_ROOT,
                              packages=init_params.PIP_PACKAGES,
                              rebuild=False,
                              quiet=True)

    # Restart inside the virtual environment. Does not return.
    # '--' prevents the Python program from confusing jiig/tool options with its own.
    log_message('Re-running inside virtual environment...', verbose=True)
    os.execl(venv_interpreter,
             venv_interpreter,
             script_path,
             tool_path,
             '--',
             *cli_args)


def load_tool(script_path: Text, init_params: Dict) -> init_file.ParamData:
    """
    Load the tool script and post-process global tool options.

    :param script_path: path to tool script
    :param init_params: data loaded from init file
    """
    script_symbols = execute_source(file=script_path)
    # If no name was provided use the script base name.
    if not registry.ToolOptions.name:
        registry.ToolOptions.name = os.path.basename(script_path)
    # If no description was provided try to scrape it from the doc string, if it exists.
    if not registry.ToolOptions.description:
        doc_string = script_symbols.get('__doc__', '').strip()
        if doc_string:
            registry.ToolOptions.description = doc_string.splitlines()[0]
    if not registry.ToolOptions.description:
        registry.ToolOptions.description = '(no description provided)'
    # Load standard modules, if enabled.
    if not registry.ToolOptions.disable_help:
        import jiig.tasks.help      # noqa
    if not registry.ToolOptions.disable_alias:
        import jiig.tasks.alias     # noqa
    # Initialize tool parameters.
    tool_params = init_file.ParamData(init_params)
    tool_params['JIIG_ROOT'] = JIIG_ROOT
    tool_params['TOOL_NAME'] = registry.ToolOptions.name
    tool_params['TOOL_DESCRIPTION'] = registry.ToolOptions.description
    return tool_params


def expand_alias(tool_name: Text, command_args: List[Text]) -> List[Text]:
    """
    Finalize command line argument list.

    Remove '--' that may have been inserted when restarting in the venv.

    Expanding an alias, if one is the first argument.

    :param tool_name:
    :param command_args:
    :return:
    """
    if not command_args:
        return []
    if not aliases.expand_name(command_args[0]):
        return command_args
    alias_manager = aliases.AliasManager(tool_name=tool_name)
    alias = alias_manager.resolve_alias(command_args[0])
    if not alias:
        abort(f'Alias "{command_args[0]}" not found.')
    return alias.command + command_args[1:]


def need_trailing_arguments(command_args: List[Text]) -> bool:
    """
    Check if the task command requires a trailing argument capture.

    :param command_args: command line arguments (only the first is used)
    :return: True if trailing arguments must be captured
    """
    if not command_args:
        return False
    # Access the mapped task to see if trailing arguments are used.
    dest_name = make_dest_name(command_args[0])
    primary_mt = registry.MAPPED_TASKS_BY_DEST_NAME.get(dest_name)
    return primary_mt and primary_mt.need_trailing_arguments


def run_tool_task(cli_results: parser.CommandLineData,
                  tool_params: init_file.ParamData):
    """
    Run the tool task based on the parsed command line.

    :param cli_results: results of parsing the command line
    :param tool_params: tool parameters based on init file and tool script
    """
    # Bundle the data shared with tasks through the task runner.
    runner_data = task_runner.RunnerData(cli_results.args,
                                         cli_results.trailing_args,
                                         cli_results.help_formatters,
                                         tool_params)
    try:
        # Execute task dependencies first.
        for dependency_task in cli_results.mapped_task.execution_tasks:
            dependency_task.task_function(registry.create_runner(runner_data))
        # Then execute the primary task.
        cli_results.mapped_task.task_function(registry.create_runner(runner_data))
    except RuntimeError as exc:
        abort(f'{exc.__class__.__name__}("{exc}")', cli_results.args)
    except KeyboardInterrupt:
        print('')


def main():
    # Skip leading '--', which is used to hide Jiig options from the Python
    # executable when restarting in the virtual environment.
    if len(sys.argv) < 2 or not os.path.isfile(sys.argv[1]):
        sys.stderr.write(f'FATAL: jiig-run should not be run directly.{os.linesep}')
        sys.exit(1)
    cli_args = sys.argv[2:]
    if cli_args and cli_args[0] == '--':
        cli_args = cli_args[1:]
    # Get global options and trailing command arguments.
    tool_args = pre_parse_arguments(cli_args)
    # Initialize the runtime environment. May not return if a venv is required.
    init_params = initialize(sys.argv[0], sys.argv[1], cli_args)
    # Load the tool to let it initialize.
    tool_params = load_tool(sys.argv[1], init_params)
    # Expand an alias, as needed.
    final_tool_args = expand_alias(tool_params.TOOL_NAME, tool_args)
    # Check if trailing arguments should be captured, e.g. for the "alias" task.
    capture_trailing = need_trailing_arguments(final_tool_args)
    # Parse the command line for real.
    cli_results = parser.parse_command_line(cli_args=final_tool_args,
                                            name=tool_params.TOOL_NAME,
                                            description=tool_params.TOOL_DESCRIPTION,
                                            capture_trailing=capture_trailing)
    # Run the tool to invoke the specified task.
    run_tool_task(cli_results, tool_params)


if __name__ == '__main__':
    main()
