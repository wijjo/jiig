#!/usr/bin/env python3

"""
Main Jiig program.

Loads any init.jiig files in this script's folder and the work folder.
"""

import sys
import os
from typing import Text, Any, Dict, Optional, List, Union, Tuple

INIT_FILE = 'init.jiig'


def abort(message: Text):
    """Display fatal error message and exit with error return code."""
    sys.stderr.write(f'{os.linesep}FATAL: {message}{os.linesep}')
    sys.exit(1)


class NoDefault:
    """Default value type for when no default value is provided."""
    pass


class Param:
    """Generic parameter type."""

    def __init__(self,
                 name: Text,
                 initial_value: Any = None,
                 default_value: Any = NoDefault):
        self.name = name
        self.value = initial_value
        self.default_value = default_value

    def error(self, message: Text):
        abort(f'{INIT_FILE}: {self.name}: {message}')

    def set(self, value: Any):
        self.value = value

    def finalize(self):
        if self.default_value is NoDefault and self.value is None:
            self.error('Value is required.')
        if self.value is None:
            self.value = self.default_value


class ParamString(Param):
    """Parameter with a text string."""

    def __init__(self,
                 name: Text,
                 initial_value: Text = None,
                 default_value: Any = NoDefault,
                 reject_empty: bool = False):
        self.reject_empty = reject_empty
        if initial_value is not None and not isinstance(initial_value, str):
            self.error('Initial value is not a string.')
        super().__init__(name,
                         initial_value=initial_value,
                         default_value=default_value)

    def set(self, value: Text):
        if not isinstance(value, str):
            self.error('Value is not a string.')
        super().set(value)

    def finalize(self):
        super().finalize()
        if self.reject_empty and isinstance(self.value, str) and not self.value:
            self.error('String value is empty.')


class ParamFolder(ParamString):

    def __init__(self,
                 name: Text,
                 initial_value: Text = None):
        super().__init__(name, initial_value=initial_value, default_value='')

    def set(self, value: Text):
        super().set(os.path.abspath(value))


class ParamDict(Param):
    """Parameter with generic dictionary."""

    def __init__(self,
                 name: Text,
                 initial_value: Dict = None,
                 default_value: Optional[Union[Dict, NoDefault]] = NoDefault):
        if initial_value is not None and not isinstance(initial_value, dict):
            self.error('Initial value is not a dictionary.')
        if default_value is None:
            default_value = {}
        super().__init__(name,
                         initial_value=initial_value,
                         default_value=default_value)

    def set(self, value: Dict):
        if not isinstance(value, dict):
            self.error('Value is not a dictionary.')
        if self.value is None:
            self.value = {}
        self.value.update(value)


class ParamList(Param):
    """Parameter with generic list."""

    def __init__(self,
                 name: Text,
                 unique: bool = False,
                 initial_value: Union[List, Tuple, Text] = None,
                 default_value: Optional[Union[List, Tuple, Text, NoDefault]] = NoDefault):
        self.unique = unique
        if initial_value is not None:
            initial_value = self.list_of(initial_value, 'Initial value')
        if default_value is not NoDefault:
            if default_value is None:
                default_value = []
            else:
                default_value = self.list_of(default_value, 'Default value')
        super().__init__(name,
                         initial_value=initial_value,
                         default_value=default_value)

    def list_of(self, value: Union[List, Tuple, Text], label: Text) -> List:
        if isinstance(value, list):
            return value
        if isinstance(value, tuple):
            return list(value)
        if isinstance(value, str):
            return [value]
        self.error(f'{label} is not a list.')

    def set(self, value: Union[List, Text]):
        if self.value is None:
            self.value = []
        self.value.extend(self.list_of(value, 'Value'))

    def finalize(self):
        super().finalize()
        if self.unique and self.value:
            self.value = list(set(self.value))


class ParamFolderList(ParamList):
    """Parameter with list of absolute folder paths."""

    def __init__(self,
                 name: Text,
                 initial_value: Union[List, Tuple, Text] = None,
                 default_value: Optional[Union[List, Tuple, Text, NoDefault]] = NoDefault):
        if initial_value is not None:
            initial_value = self.path_list(initial_value, 'Initial value')
        if default_value is not NoDefault:
            if default_value is None:
                default_value = []
            else:
                default_value = self.path_list(default_value, 'Default value')
        super().__init__(name,
                         initial_value=initial_value,
                         default_value=default_value)

    def path_list(self, value: Union[List, Tuple, Text], label: Text) -> List[Text]:
        return [os.path.abspath(path) for path in self.list_of(value or [], label)]

    def set(self, value: List[Text]):
        if self.value is None:
            self.value = []
        super().set(self.path_list(value, 'Value'))


class ParamFolderDict(ParamDict):
    """Parameter with dictionary mapping names to absolute folder paths."""

    def __init__(self,
                 name: Text,
                 initial_value: Dict[Text, Text] = None,
                 default_value: Optional[Union[Dict[Text, Text], NoDefault]] = NoDefault):
        if initial_value is not None:
            initial_value = self.path_dict(initial_value)
        if default_value is not NoDefault and default_value is not None:
            default_value = self.path_dict(default_value)
        super().__init__(name,
                         initial_value=initial_value,
                         default_value=default_value)

    @staticmethod
    def path_dict(value: Dict[Text, Text]) -> Dict[Text, Text]:
        return {name: os.path.abspath(path) for name, path in value.items()}

    def set(self, value: Dict[Text, Text]):
        if self.value is None:
            self.value = {}
        super().set(self.path_dict(value))


class ParamData(dict):
    """Parameter data dictionary with attribute read access."""
    def __getattr__(self, name: Text) -> Any:
        return self.get(name)


class ParamContainer:
    """Used to accumulate parameter data from init files."""

    param_types = [
        ParamString('APP_NAME'),
        ParamFolder('BASE_FOLDER'),
        ParamFolder('VENV_FOLDER'),
        ParamFolderList('LIB_FOLDERS'),
        ParamFolderDict('TASK_PACKAGES'),
        ParamList('PIP_PACKAGES', unique=True, default_value=[]),
    ]

    def __init__(self):
        self._params = {param.name: param for param in self.param_types}

    def update(self, raw_dict: Dict):
        """Merge parameter data."""
        for name, value in raw_dict.items():
            if name and name[0].isupper():
                if name not in self._params:
                    self._params[name] = Param(name)
                if value is not None:
                    self._params[name].set(value)

    def finalize(self) -> ParamData:
        """Perform final checks and return the parameter data dictionary object."""
        for param in self._params.values():
            param.finalize()
        return ParamData({name: param.value for name, param in self._params.items()})


def init_folder(param_container: ParamContainer, folder_path: Text):
    """Load parameter data from an init file in a specified folder."""
    if not os.path.isfile(os.path.join(folder_path, INIT_FILE)):
        return
    # Change the work folder to properly handle relative paths.
    original_folder_path = os.getcwd()
    os.chdir(folder_path)
    try:
        symbols = {}
        try:
            with open(INIT_FILE, encoding='utf-8') as init_file:
                init_text = init_file.read()
        except (IOError, OSError) as exc:
            abort(f'Unable to read configuration file: {INIT_FILE}: {exc}')
        exec(init_text, symbols)
        param_container.update(symbols)
    finally:
        os.chdir(original_folder_path)


def load_params() -> ParamData:
    """Load parameter data from application and Jiig init files."""
    param_container = ParamContainer()
    jiig_folder = os.path.dirname(os.path.realpath(__file__))
    init_folder(param_container, jiig_folder)
    work_folder = os.getcwd()
    if work_folder != jiig_folder:
        init_folder(param_container, work_folder)
    params = param_container.finalize()
    return params


def check_virtual_environment(params: ParamData):
    """
    Make sure we're running in the virtual environment.

    Builds the virtual environment if it is missing.

    Re-executes using the proper (virtual environment) interpreter if we're
    running outside of the virtual environment.
    """
    venv_python_path = os.path.join(params.VENV_FOLDER, 'bin', 'python')
    if sys.executable != venv_python_path:
        from jiig.utility import build_virtual_environment
        build_virtual_environment(params.VENV_FOLDER,
                                  packages=params.PIP_PACKAGES,
                                  rebuild=False,
                                  quiet=True,
                                  dry_run=False)
        os.execlp(venv_python_path, venv_python_path, *sys.argv)


def jiig_main():
    """ Run the Jiig application inside a custom virtual environment."""
    params = load_params()
    if params.LIB_FOLDERS:
        for lib_folder in reversed(params.LIB_FOLDERS):
            sys.path.insert(0, lib_folder)
    check_virtual_environment(params)
    from jiig.main import main
    main(app_name=params.APP_NAME,
         base_folder=params.BASE_FOLDER,
         venv_folder=params.VENV_FOLDER,
         task_packages=params.TASK_PACKAGES,
         pip_packages=params.PIP_PACKAGES)


if __name__ == '__main__':
    jiig_main()
